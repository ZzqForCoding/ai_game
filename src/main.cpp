// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "code_running_server/CodeRunning.h"
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/ThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>
#include <thrift/transport/TBufferTransports.h>
#include "message_client/Message.h"

#include <boost/filesystem.hpp>
#include <iostream>
#include <vector>
#include <cstdlib>
#include <sstream>
#include <fstream>
#include <exception>
#include <jsoncpp/json/json.h>
#include "thread"
#include "mutex"
#include "condition_variable"
#include "queue"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::code_running_service;

using namespace std;
typedef pair<int, int> PII;

struct MessageQueue {
    queue<Bot> q;
    mutex m;
    condition_variable cv;
} message_queue;

struct Result
{
    int status;
    string output;
    string error;
};

class CodeRunningHandler : virtual public CodeRunningIf {
    public:
        CodeRunningHandler() {
            // Your initialization goes here
        }

        int32_t add_bot_code(const Bot& bot, const std::string& info) {
            // Your implementation goes here
            unique_lock<mutex> lock1(message_queue.m);
            message_queue.q.push(bot);
            message_queue.cv.notify_all();
            return 0;
        }

};

class CodeRunningCloneFactory : virtual public CodeRunningIfFactory {
    public:
        ~CodeRunningCloneFactory() override = default;
        CodeRunningIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) override
        {
            std::shared_ptr<TSocket> sock = std::dynamic_pointer_cast<TSocket>(connInfo.transport);
            /*cout << "Incoming connection\n";
              cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
              cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
              cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
              cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";*/
            return new CodeRunningHandler;
        }
        void releaseHandler(CodeRunningIf* handler) override {
            delete handler;
        }
};

vector<string> split(const string& str, const string& sep) {
    vector<string> ret;
    if("" == str) return ret;

    //先将要切割的字符串从string类型转换为char*类型
    char *strs = new char[str.length() + 1] ;
    strcpy(strs, str.c_str());

    char *seps = new char[sep.length() + 1];
    strcpy(seps, sep.c_str());

    char *p = strtok(strs, seps);
    while(p) {
        string s = p;     //分割得到的字符串转换为string类型
        ret.push_back(s); //存入结果数组
        p = strtok(NULL, seps);
    }

    return ret;
}

string concatStr(string one, string two="", string three="", string four="", string five="") {
    return one + two + three + four + five;
}

bool check_tail_increasing(int step) {
    if(step <= 10) return true;
    return step % 3 == 1;
}

vector<PII> getCells(int sx, int sy, string steps) {
    steps = steps.substr(1, steps.length() - 2);
    vector<PII> ret;

    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    int x = sx, y = sy;
    int step = 0;
    ret.push_back({x, y});
    for(int i = 0; i < steps.length(); i++) {
        int d = steps[i] - '0';
        x += dx[d], y += dy[d];
        ret.push_back({x, y});
        if(!check_tail_increasing(++step)) {
            ret.erase(ret.begin());
        }
    }
    return ret;
}

std::string generate_tmpfile_name()
{
    std::ostringstream ss;
    ss << "/tmp/" << boost::filesystem::unique_path().native();
    return ss.str();
}

Result exec(std::string command)
{
    const auto out_file = generate_tmpfile_name();
    const auto err_file = generate_tmpfile_name();

    // Redirect output of the command appropriately
    std::ostringstream ss;
    ss << command.c_str() << " >" << out_file << " 2>" << err_file;
    const auto cmd = ss.str();

    // Call the command
    const auto status = std::system(cmd.c_str());

    // Read the output from the files and remove them
    std::ostringstream out_stream;
    std::ostringstream err_stream;
    ifstream infile1(out_file);
    out_stream << infile1.rdbuf();
    infile1.close();
    ifstream infile2(err_file);
    err_stream << infile2.rdbuf();
    infile2.close();
    std::remove(out_file.c_str());
    std::remove(err_file.c_str());

    // Store the output
    Result result;
    result.status = status;
    result.output = out_stream.str();
    result.error  = err_stream.str();

    return result;
}

void save_result(string info) {
    std::shared_ptr<TTransport> socket(new TSocket("120.76.157.21", 9091));
    std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    MessageClient client(protocol);

    try {
        transport->open();
        client.response(info);
        transport->close();
    } catch (TException& tx) {
        cout << "ERROR: " << tx.what() << endl;
    }
}

void processInput(string input, string dockerId) {
    // 处理输入
    // 地图#my.sx#my.sy#my操作#you.sx#you.sy#you操作
    vector<string> v = split(input, "#");
    string newInput;
    for(int i = 0, k = 0; i < 13; i++) {
        for(int j = 0; j < 14; j++, k++) {
            if(v[0][k] == '0') newInput += "0";
            else newInput += "1";
            if(j != 13) newInput += " ";
        }
        newInput += "\n";
    }

    vector<PII> aCells = getCells(stoi(v[1]), stoi(v[2]), v[3]);
    vector<PII> bCells = getCells(stoi(v[4]), stoi(v[5]), v[6]);

    newInput += to_string(aCells.size()) + "\n";
    for(int i = 0; i < aCells.size(); i++)
        newInput += to_string(aCells[i].first) + " " + to_string(aCells[i].second) + "\n";

    newInput += to_string(bCells.size()) + "\n";
    for(int i = 0; i < aCells.size(); i++)
        newInput += to_string(bCells[i].first) + " " + to_string(bCells[i].second) + "\n";

    string infile = generate_tmpfile_name();
    system(concatStr("echo '", newInput, "' > " + infile).c_str());
    system(concatStr("docker cp " + infile + " ", dockerId, ":/tmp/input.txt").c_str());
    system(concatStr("rm ", infile).c_str());
}

void run(Bot bot, string dockerId) {
    // 新建容器
    // Result result = exec("docker run -itd code_runner:2.0 /bin/bash");
    // string dockerId = result.output.substr(0, 12);
    system(concatStr("docker start ", dockerId).c_str());
    // 分配的不准
    system(concatStr("docker update ", dockerId, " --memory 64MB --memory-swap -1").c_str());

    processInput(bot.input, dockerId);

    string resp, infile = generate_tmpfile_name();
    Result codeResult;
    if(bot.language == "cpp") {
        // 处理代码
        bot.botCode += "\n\n#include <thread>\n\
#include <unistd.h>\n\
\n\
void startTime() {\n\
    sleep(2.5);\n\
    cerr << \"Time Limit Exceeded\";\n\
    exit(0);\n\
}\n\
\n\
int main() {\n\
    thread t(startTime);\n\
    t.detach();\n\
    int x = nextStep();\n\
    cout << endl << x;\n\
    return 0;\n\
}\n";
        ofstream fon(infile + ".cpp");
        fon << bot.botCode;
        fon.close();
        codeResult = exec(concatStr("g++ -Wall -o ", infile, ".out ", infile, ".cpp -pthread").c_str());
        system(concatStr("rm ", infile, ".cpp").c_str());
        if(codeResult.status == 0) {
            system(concatStr("docker cp " + infile + ".out ", dockerId, ":/tmp/code.out").c_str());
            system(concatStr("rm ", infile, ".out").c_str());
            // 编译运行
            try {
                codeResult = exec(concatStr("docker exec ", dockerId, " /bin/bash -c  '/tmp/code.out < /tmp/input.txt'"));
            } catch(exception e) {
                cout << "except" << endl;
            }
            // 错误代码处理
            if(codeResult.status == 35584) codeResult.error = "Memory Limit Exceeded";
        }
    } else if(bot.language == "java") {
        // 处理代码
        int pos = bot.botCode.rfind("}");
        bot.botCode.insert(pos, "\n    public static void main(String[] args) {\n\
        StartTime st = new StartTime();\n\
        st.setDaemon(true);\n\
        st.start();\n\
        Integer x = nextStep();\n\
        System.out.println();\n\
        System.out.println(x);\n\
    }\n");
        bot.botCode += "\n\nclass StartTime extends Thread {\n\
    public void run() {\n\
        try {\n\
            Thread.sleep(2500);\n\
            System.err.println(\"Time Limit Exceeded\");\n\
            System.exit(0);\n\
        } catch (InterruptedException e) {\n\
            e.printStackTrace();\n\
        }\n\
    }\n\
}\n";
        ofstream fon(infile + ".java");
        fon << bot.botCode;
        fon.close();
        system(concatStr("docker cp " + infile  + ".java ", dockerId, ":/tmp/Main.java").c_str());
        system(concatStr("rm ", infile, ".java").c_str());
        // 编译运行
        try {
            codeResult = exec(concatStr("docker exec ", dockerId, " /bin/bash -c 'java /tmp/Main.java < /tmp/input.txt'"));
        } catch(exception e) {
            cout << "except" << endl;
        }
    } else if(bot.language == "python") {
        // 处理代码
        bot.botCode += "\n\nimport sys\n\
import os\n\
import time\n\
import threading\n\
\n\
def startTime():\n\
    time.sleep(2.5)\n\
    print(\"Time Limit Exceeded\", file=sys.stderr)\n\
    os._exit(0)\n\
\n\
if __name__ == '__main__':\n\
    t = threading.Thread(target=startTime)\n\
    t.setDaemon(True)\n\
    t.start()\n\
    c = nextStep()\n\
    print()\n\
    print(c)\n";

        ofstream fon(infile + ".py");
        fon << bot.botCode;
        fon.close();

        system(concatStr("docker cp " + infile + ".py ", dockerId, ":/tmp/code.py").c_str());
        system(concatStr("rm ", infile, ".py").c_str());

        // 编译运行
        try {
            codeResult = exec(concatStr("docker exec ", dockerId, " /bin/bash -c 'python3 /tmp/code.py < /tmp/input.txt'"));
        } catch(exception e) {
            cout << "except" << endl;
        }
        if(codeResult.error.find("3709 Killed") != -1) {
            codeResult.error = "IndexError: list index out of range";
        }
    }
    // 将运行结果与输出处理
    vector<string> output = split(codeResult.output, "\n");

    int outputLen = output.size();
    string output1, output2;
    if(outputLen != 0) {
        output2 = output[outputLen - 1];
        for(int i = 0; i < outputLen - 1; i++) {
            output1 += output[i];
            if(i != outputLen - 2) output1 += "\n";
        }
    }

    // 传输结果
    Json::Value root;
    root["type"] = Json::Value("bot_move");
    root["room_name"] = Json::Value(bot.room_name);
    root["user_id"] = Json::Value(bot.userId);
    root["compile"] = Json::Value(codeResult.error);
    root["output"] = Json::Value(output1);
    root["result"] = Json::Value(output2);
    root["status"] = Json::Value(codeResult.status);
    resp = Json::FastWriter().write(root);
    save_result(resp);

    system(concatStr("docker kill ", dockerId).c_str());
    // system(concatStr("docker rm ", dockerId).c_str());
}

void consume_task1() {
    while(true) {
        unique_lock<mutex> lock1(message_queue.m);
        if(message_queue.q.empty()) {
            message_queue.cv.wait(lock1);
        } else {
            Bot bot = message_queue.q.front();
            message_queue.q.pop();
            lock1.unlock();
            run(bot, "6ed0654416c4");
        }
    }
}

void consume_task2() {
    while(true) {
        unique_lock<mutex> lock1(message_queue.m);
        if(message_queue.q.empty()) {
            message_queue.cv.wait(lock1);
        } else {
            Bot bot = message_queue.q.front();
            message_queue.q.pop();
            lock1.unlock();
            run(bot, "ff187b4ffbf2");
        }
    }
}

int main(int argc, char **argv) {
    TThreadedServer server(
            std::make_shared<CodeRunningProcessorFactory>(std::make_shared<CodeRunningCloneFactory>()),
            std::make_shared<TServerSocket>(9090), //port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>());

    printf("Starting BotRunning Server...\n");

    thread code_running_thread1(consume_task1);
    thread code_running_thread2(consume_task2);
    server.serve();
    return 0;
}

